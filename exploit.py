import bittensor as bt
import time
import pandas as pd
import random
from rdkit import Chem, DataStructs
from rdkit.Chem import Descriptors, MACCSkeys, AllChem
from rdkit.Chem import rdFingerprintGenerator
from dataclasses import dataclass, field
from typing import List, Tuple, Dict

from molecules import MoleculeManager, MoleculeUtils
FCFP_GEN = rdFingerprintGenerator.GetMorganGenerator(
    radius=2, fpSize=2048,
    atomInvariantsGenerator=rdFingerprintGenerator.GetMorganFeatureAtomInvGen()
)
MORGAN_FP_GENERATOR = rdFingerprintGenerator.GetMorganGenerator(radius=2, fpSize=2048)

STAGE1_THRESHOLDS = {'tanimoto': 0.40, 'fcfp': 0.40}

STAGE2_WEIGHTS = {'tanimoto': 0.40, 'fcfp': 0.35, 'tversky': 0.25}


@dataclass
class WinnerRef:
    name: str
    smiles: str
    mol: object = None
    morgan_fp: object = None
    fcfp_fp: object = None

    def __post_init__(self):
        if self.mol is None and self.smiles:
            self.mol = Chem.MolFromSmiles(self.smiles)
        if self.mol and self.morgan_fp is None:
            self.morgan_fp = MORGAN_FP_GENERATOR.GetFingerprint(self.mol)
        if self.mol and self.fcfp_fp is None:
            self.fcfp_fp = FCFP_GEN.GetFingerprint(self.mol)


@dataclass
class ExploitCandidate:
    name: str
    smiles: str
    mol: object = None
    morgan_fp: object = None
    fcfp_fp: object = None
    metrics: Dict[str, float] = field(default_factory=dict)
    composite_score: float = 0.0
    winner_ref: str = ""


def _calc_composite_score(metrics: Dict[str, float]) -> float:
    return sum(STAGE2_WEIGHTS.get(k, 0) * v for k, v in metrics.items())


def _exploit_single_reactant(
    reactant_id: int,
    reactant_type: str,
    winner: WinnerRef,
    config: dict,
    manager: MoleculeManager,
    limit: int = 50,
    avoid_names: set = None,
) -> List[ExploitCandidate]:
    rxn_id = manager.rxn_id

    t_total = time.perf_counter()

    if avoid_names is None:
        avoid_names = set()

    # Step 1: partner selection
    t0 = time.perf_counter()

    if reactant_type == 'A':
        partners = manager.molecules_B
    else:
        partners = manager.molecules_A

    candidates_info = []

    remaining_partner_ids = {p[0] for p in partners}
    validated_chunks = []
    validated_count = 0
    target_count = 5000
    batch_size = 200
    while (
        validated_count < target_count
        and len(remaining_partner_ids) > 0
    ):

        current_batch_size = min(batch_size, len(remaining_partner_ids))

        batch_ids = random.sample(
            list(remaining_partner_ids),
            current_batch_size
        )

        # remove sampled ids so they won't repeat
        remaining_partner_ids.difference_update(batch_ids)

        candidates_info = []

        for partner_id in batch_ids:

            if reactant_type == 'A':
                rxn_name = f"rxn:{rxn_id}:{reactant_id}:{partner_id}"
            else:
                rxn_name = f"rxn:{rxn_id}:{partner_id}:{reactant_id}"

            if rxn_name in avoid_names:
                continue

            candidates_info.append(rxn_name)

        if not candidates_info:
            continue

        batch_df = pd.DataFrame({"name": candidates_info})

        valid_df = manager.validate_molecules(config, batch_df)

        if len(valid_df) > 0:
            validated_chunks.append(valid_df)
            validated_count += len(valid_df)
            
    if not validated_chunks:
        print("[TIME] validation_sampling: 0.0000 sec (no valid molecules)")
        return []

    valid_df = pd.concat(validated_chunks, ignore_index=True)    

    bt.logging.info(f"[TIME] partner_selection: {time.perf_counter() - t0:.4f} sec")

    # Step 3: molecule creation
    t0 = time.perf_counter()

    valid_df["mols"] = valid_df["smiles"].apply(
        MoleculeUtils.mol_from_smiles_cached
    )

    bt.logging.info(f"[TIME] mol_creation: {time.perf_counter() - t0:.4f} sec")

    # Step 4: fingerprint generation
    t0 = time.perf_counter()

    valid_df["morgan_fp"] = valid_df["mols"].apply(
        MORGAN_FP_GENERATOR.GetFingerprint
    )
    valid_df["fcfp_fp"] = valid_df["mols"].apply(
        FCFP_GEN.GetFingerprint
    )

    bt.logging.info(f"[TIME] fingerprint_generation: {time.perf_counter() - t0:.4f} sec")

    # Step 5: similarity calculation
    t0 = time.perf_counter()

    morgan_fps = valid_df["morgan_fp"].to_list()
    fcfp_fps = valid_df["fcfp_fp"].to_list()

    valid_candidates = valid_df[
        ["name", "smiles", "mols", "morgan_fp", "fcfp_fp"]
    ]

    morgan_sims = DataStructs.BulkTanimotoSimilarity(
        winner.morgan_fp, morgan_fps
    )
    fcfp_sims = DataStructs.BulkTanimotoSimilarity(
        winner.fcfp_fp, fcfp_fps
    )

    bt.logging.info(f"[TIME] similarity_calculation: {time.perf_counter() - t0:.4f} sec")

    # Step 6: stage1 filtering
    t0 = time.perf_counter()

    stage1_passed = []

    for i, row in enumerate(valid_candidates.itertuples(index=False)):
        tanimoto = morgan_sims[i]
        fcfp = fcfp_sims[i]

        if (
            tanimoto >= STAGE1_THRESHOLDS['tanimoto']
            or fcfp >= STAGE1_THRESHOLDS['fcfp']
        ):
            tversky = DataStructs.TverskySimilarity(
                row.morgan_fp, winner.morgan_fp, 0.7, 0.3
            )

            metrics = {
                'tanimoto': tanimoto,
                'fcfp': fcfp,
                'tversky': tversky
            }

            stage1_passed.append(
                ExploitCandidate(
                    name=row.name,
                    smiles=row.smiles,
                    mol=row.mols,
                    morgan_fp=row.morgan_fp,
                    fcfp_fp=row.fcfp_fp,
                    metrics=metrics,
                    composite_score=_calc_composite_score(metrics),
                    winner_ref=winner.name
                )
            )

    bt.logging.info(f"[TIME] stage1_filtering: {time.perf_counter() - t0:.4f} sec")

    # Step 7: sorting
    t0 = time.perf_counter()

    stage1_passed.sort(
        key=lambda x: x.composite_score,
        reverse=True
    )

    bt.logging.info(f"[TIME] sorting: {time.perf_counter() - t0:.4f} sec")

    bt.logging.info(f"[TIME] total: {time.perf_counter() - t_total:.4f} sec")

    return stage1_passed[:limit]

def _exploit_single_variation_3comp(
    fixed_ids: Tuple[int, int],
    vary_role: str,
    winner: WinnerRef,
    config: dict,
    manager: MoleculeManager,
    limit: int = 50,
    avoid_names: set = None,
) -> Tuple[List[ExploitCandidate], Dict[str, int]]:
    rxn_id = manager.rxn_id
    from tqdm import tqdm

    if avoid_names is None:
        avoid_names = set()

    if vary_role == 'A': partners = manager.molecules_A
    elif vary_role == 'B': partners = manager.molecules_B
    else: partners = manager.molecules_C

    candidates_info = []
    for partner_id, partner_smiles, _ in partners:
        if vary_role == 'A':
            rxn_name = f"rxn:{rxn_id}:{partner_id}:{fixed_ids[0]}:{fixed_ids[1]}"
        elif vary_role == 'B':
            rxn_name = f"rxn:{rxn_id}:{fixed_ids[0]}:{partner_id}:{fixed_ids[1]}"
        else:
            rxn_name = f"rxn:{rxn_id}:{fixed_ids[0]}:{fixed_ids[1]}:{partner_id}"

        if rxn_name in avoid_names: continue
        candidates_info.append(rxn_name)

    candidates_df = pd.DataFrame({"name": candidates_info})
    valid_df = manager.validate_molecules(config, candidates_df)
    valid_df["mols"] = valid_df["smiles"].apply(MoleculeUtils.mol_from_smiles_cached)
    valid_df["morgan_fp"] = valid_df["mols"].apply(MORGAN_FP_GENERATOR.GetFingerprint)
    valid_df["fcfp_fp"] = valid_df["mols"].apply(FCFP_GEN.GetFingerprint)
    
    morgan_fps = valid_df["morgan_fp"].to_list()
    fcfp_fps = valid_df["fcfp_fp"].to_list()
    valid_candidates = valid_df[["name", "smiles", "mols", "morgan_fp", "fcfp_fp"]]
    
    morgan_sims = DataStructs.BulkTanimotoSimilarity(winner.morgan_fp, morgan_fps)
    fcfp_sims = DataStructs.BulkTanimotoSimilarity(winner.fcfp_fp, fcfp_fps)

    stage1_passed = []
    for i, row in enumerate(valid_candidates.itertuples(index=False)):
        tanimoto = morgan_sims[i]
        fcfp = fcfp_sims[i]

        if tanimoto >= STAGE1_THRESHOLDS['tanimoto'] or fcfp >= STAGE1_THRESHOLDS['fcfp']:
            tversky = DataStructs.TverskySimilarity(row.morgan_fp, winner.morgan_fp, 0.7, 0.3)
            metrics = {'tanimoto': tanimoto, 'fcfp': fcfp, 'tversky': tversky}
            stage1_passed.append(
                ExploitCandidate(
                    name=row.name,
                    smiles=row.smiles,
                    mol=row.mols,
                    morgan_fp=row.morgan_fp,
                    fcfp_fp=row.fcfp_fp,
                    metrics=metrics,
                    composite_score=_calc_composite_score(metrics),
                    winner_ref=winner.name
                )
            )

    stage1_passed.sort(key=lambda x: x.composite_score, reverse=True)
    return stage1_passed[:limit]


def get_top_n_unexploited(top_molecules: list, exploited_reactants: set, n: int = 5) -> list:
    selected = []
    for i, mol in enumerate(top_molecules):
        if len(selected) >= n:
            break
        name = mol.get("name", "")
        parts = name.split(":")
        if len(parts) >= 4:
            try:
                rxn_id = int(parts[1])
                id_A = int(parts[2])
                id_B = int(parts[3])
                id_C = int(parts[4]) if len(parts) == 5 else None

                if id_C is not None and rxn_id == 5:
                    if ('A', id_A) not in exploited_reactants or ('B', id_B) not in exploited_reactants or ('C', id_C) not in exploited_reactants:
                        selected.append(mol)
                else:
                    if id_A not in exploited_reactants or id_B not in exploited_reactants:
                        selected.append(mol)
                    elif id_C is not None and id_C not in exploited_reactants:
                        selected.append(mol)
            except (ValueError, IndexError):
                pass
    return selected


def run_exploit(
    top_molecules: List[Dict],
    manager: MoleculeManager,
    config: dict,
    top_n: int = 3,
    limit_per_reactant: int = 2000,
    avoid_names: set = None,
    exploited_reactants: set = None,
) -> Tuple[List[Dict], Dict]:
    if avoid_names is None: avoid_names = set()
    if exploited_reactants is None: exploited_reactants = set()

    local_avoid = set(avoid_names)
    if manager.is_three_component:
        return _exploit_3comp(
            top_molecules, manager, config, top_n, limit_per_reactant, local_avoid, exploited_reactants,
        )

    unique_reactants = {}
    for mol_info in top_molecules[:top_n]:
        name = mol_info.get("name", "")
        smiles = mol_info.get("smiles", "")

        if not name or not smiles:
            continue

        parts = name.split(":")
        if len(parts) < 4:
            continue

        try:
            id_A = int(parts[2])
            id_B = int(parts[3])
        except (ValueError, IndexError):
            continue

        winner = WinnerRef(name=name, smiles=smiles)
        if winner.mol is None:
            continue

        # Collect multiple unexploited reactants from the top molecules
        if id_A not in unique_reactants and id_A not in exploited_reactants:
            unique_reactants[id_A] = {'type': "A", 'winner': winner}
        if id_B not in unique_reactants and id_B not in exploited_reactants:
            unique_reactants[id_B] = {'type': "B", 'winner': winner}

    bt.logging.info(f"[Exploit] Found {len(unique_reactants)} unique reactants")

    all_candidates = []
    summary = {
        'unique_reactants': len(unique_reactants),
        'reactants_exploited': 0,
        'total_candidates': 0,
        'exploited_reactant_ids': set()
    }

    for reactant_id, info in unique_reactants.items():
    
        candidates = _exploit_single_reactant(
            config=config,
            manager=manager,
            reactant_id=reactant_id,
            reactant_type=info['type'],
            winner=info['winner'],
            limit=limit_per_reactant,
            avoid_names=local_avoid,
        )

        all_candidates.extend(candidates)
        summary['reactants_exploited'] += 1
        summary['exploited_reactant_ids'].add(reactant_id)

        for c in candidates:
            local_avoid.add(c.name)

    summary['total_candidates'] = len(all_candidates)

    results = [{"name": c.name, "smiles": c.smiles} for c in all_candidates]

    return results, summary


def _exploit_3comp(
    top_molecules: List[Dict],
    manager: MoleculeManager,
    config: dict,
    top_n: int,
    limit_per_reactant: int,
    local_avoid: set,
    exploited_reactants: set,
) -> Tuple[List[Dict], Dict]:
    rxn_id = manager.rxn_id
    exploited_tuples = set()
    all_candidates = []
    summary = {
        'molecules_processed': 0,
        'variations_exploited': 0,
        'total_candidates': 0,
        'exploited_reactant_ids': set()
    }

    for mol_info in top_molecules[:top_n]:
        name = mol_info.get("name", "")
        smiles = mol_info.get("smiles", "")

        if not name or not smiles:
            continue

        parts = name.split(":")
        if len(parts) != 5:
            continue

        try:
            id_A = int(parts[2])
            id_B = int(parts[3])
            id_C = int(parts[4])
        except (ValueError, IndexError):
            continue

        winner = WinnerRef(name=name, smiles=smiles)
        if winner.mol is None:
            continue

        summary['molecules_processed'] += 1

        use_tuple_tracking = (rxn_id == 5)

        tuple_key = ('A', id_B, id_C)
        check_key_A = ('A', id_A) if use_tuple_tracking else id_A
        if tuple_key not in exploited_tuples and check_key_A not in exploited_reactants:
            candidates = _exploit_single_variation_3comp(
                fixed_ids=(id_B, id_C), vary_role='A', winner=winner,
                config=config, manager=manager,
                limit=limit_per_reactant, avoid_names=local_avoid,
            )
            all_candidates.extend(candidates)
            summary['variations_exploited'] += 1
            summary['exploited_reactant_ids'].add(('A', id_A) if use_tuple_tracking else id_A)
            exploited_tuples.add(tuple_key)
            for c in candidates: local_avoid.add(c.name)
            break

        tuple_key = ('B', id_A, id_C)
        check_key_B = ('B', id_B) if use_tuple_tracking else id_B
        if tuple_key not in exploited_tuples and check_key_B not in exploited_reactants:
            candidates = _exploit_single_variation_3comp(
                fixed_ids=(id_A, id_C), vary_role='B', winner=winner,
                config=config, manager=manager,
                limit=limit_per_reactant, avoid_names=local_avoid,
            )
            all_candidates.extend(candidates)
            summary['variations_exploited'] += 1
            summary['exploited_reactant_ids'].add(('B', id_B) if use_tuple_tracking else id_B)
            exploited_tuples.add(tuple_key)
            for c in candidates: local_avoid.add(c.name)
            break

        tuple_key = ('C', id_A, id_B)
        check_key_C = ('C', id_C) if use_tuple_tracking else id_C
        if tuple_key not in exploited_tuples and check_key_C not in exploited_reactants:
            candidates = _exploit_single_variation_3comp(
                fixed_ids=(id_A, id_B), vary_role='C', winner=winner,
                config=config, manager=manager,
                limit=limit_per_reactant, avoid_names=local_avoid,
            )
            all_candidates.extend(candidates)
            summary['variations_exploited'] += 1
            summary['exploited_reactant_ids'].add(('C', id_C) if use_tuple_tracking else id_C)
            exploited_tuples.add(tuple_key)
            for c in candidates: local_avoid.add(c.name)
            break

    summary['total_candidates'] = len(all_candidates)

    results = [{"name": c.name, "smiles": c.smiles} for c in all_candidates]

    return results, summary